<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Upgraded Snake — HTML</title>
  <style>
    :root { --bg: #0f172a; --panel: #0b1220; --muted: #94a3b8; --accent: #34d399; --accent-dark: #065f46; --red: #ef4444; --gold: #f59e0b; }
    body { margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: linear-gradient(180deg,#071126 0%, #071226 100%); color:#e6eef8; display:flex; align-items:flex-start; justify-content:center; min-height:100vh; padding:28px; }
    .card { width:100%; max-width:980px; background:var(--panel); border-radius:12px; padding:16px; box-shadow:0 10px 30px rgba(2,6,23,0.7); }
    .hud { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:8px; }
    .controls { display:flex; gap:8px; align-items:center; }
    button { background:#0ea5a3; color:#00221a; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
    button.ghost { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.06); }
    label { color:var(--muted); font-size:13px; display:flex; gap:8px; align-items:center; }
    input[type=range] { width:120px; }
    canvas { display:block; width:100%; border-radius:8px; background:var(--bg); touch-action:none; cursor:crosshair; }
    .footer { color:var(--muted); font-size:12px; margin-top:8px; }
  </style>
</head>
<body>
  <div class="card">
    <div class="hud">
      <div>
        <h3 style="margin:0">Upgraded Snake — HTML</h3>
        <div style="color:var(--muted); font-size:13px;">Chunky snake & bigger apples</div>
      </div>
      <div class="controls">
        <label><input id="wrap" type="checkbox" checked> Wrap</label>
        <label>Speed <input id="speed" type="range" min="4" max="24" value="8"></label>
        <button id="start">Start</button>
        <button id="reset" class="ghost">Reset</button>
      </div>
    </div>

    <canvas id="game"></canvas>

    <div class="footer">
      Controls: Arrow keys / WASD. Tap to start. Space = Pause. R = Restart.
      <span id="scoreText" style="float:right"></span>
    </div>
  </div>

<script>
(() => {
  // Config (bigger visuals)
  let cellSize = 28; // <-- bigger cell size makes snake & apples large
  let cols = 32;
  let rows = 22;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const elStart = document.getElementById('start');
  const elReset = document.getElementById('reset');
  const elWrap = document.getElementById('wrap');
  const elSpeed = document.getElementById('speed');
  const scoreText = document.getElementById('scoreText');

  let speed = Number(elSpeed.value); // ticks per second (base)
  let running = false;
  let wrap = elWrap.checked;

  let snake = [];
  let dir = {x:1,y:0};
  let nextDir = null;
  let food = {x:10,y:10,type:'normal'};
  let tickInterval = 1000 / speed;
  let lastTime = 0;
  let acc = 0;
  let gameOver = false;
  let score = 0;
  let speedMultiplier = 1;
  let highScore = Number(localStorage.getItem('snake_highscore_v3') || '0');

  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function placeFood() {
    let tries=0;
    while(tries++<2000){
      const x = randInt(0,cols-1);
      const y = randInt(0,rows-1);
      if (!snake.some(p=>p.x===x&&p.y===y)){
        const type = Math.random()<0.08 ? 'golden' : 'normal';
        food = {x,y,type};
        return;
      }
    }
  }

  function resetGrid() {
    // compute cols/rows based on container width
    const containerWidth = Math.min(window.innerWidth - 100, 960);
    cols = Math.max(10, Math.floor(containerWidth / cellSize));
    rows = Math.max(8, Math.floor((window.innerHeight*0.6) / cellSize));
    // set canvas size (css width adapts)
    const dpr = window.devicePixelRatio || 1;
    canvas.width = cols * cellSize * dpr;
    canvas.height = rows * cellSize * dpr;
    canvas.style.width = (cols * cellSize) + 'px';
    canvas.style.height = (rows * cellSize) + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function resetGame() {
    const startX = Math.floor(cols/2);
    const startY = Math.floor(rows/2);
    snake = [{x:startX-1,y:startY},{x:startX,y:startY}];
    dir = {x:1,y:0};
    nextDir = null;
    score = 0;
    speedMultiplier = 1;
    gameOver = false;
    placeFood();
    updateScore();
  }

  function updateScore(){
    scoreText.textContent = `Score: ${score} · High: ${highScore}`;
  }

  function doGameOver(){
    gameOver = true;
    running = false;
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('snake_highscore_v3', String(highScore));
    }
    updateScore();
    // small flash
    setTimeout(()=>renderOverlay('Game Over — Press R to restart'), 120);
  }

  function setDir(x,y){
    if (x===-dir.x && y===-dir.y) return;
    nextDir = {x,y};
  }

  function tick(){
    if (gameOver) return;
    if (nextDir){ dir = nextDir; nextDir = null; }
    const head = snake[snake.length-1];
    let nx = head.x + dir.x;
    let ny = head.y + dir.y;

    if (wrap){
      if (nx < 0) nx = cols-1;
      if (nx >= cols) nx = 0;
      if (ny < 0) ny = rows-1;
      if (ny >= rows) ny = 0;
    } else {
      if (nx<0||nx>=cols||ny<0||ny>=rows) return doGameOver();
    }

    if (snake.some(p=>p.x===nx && p.y===ny)) return doGameOver();

    snake.push({x:nx,y:ny});
    let ate = false;
    if (nx===food.x && ny===food.y){
      ate = true;
      if (food.type==='normal') score += 10;
      else { score += 40; speedMultiplier = Math.min(2.2, speedMultiplier + 0.3); }
      placeFood();
      updateScore();
    }
    if (!ate) snake.shift();

    speedMultiplier = Math.max(1, speedMultiplier - 0.02);
    const effectiveSpeed = Number(elSpeed.value) * speedMultiplier + Math.floor(score / 80);
    tickInterval = 1000 / effectiveSpeed;
  }

  function render(){
    // background
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0,0,cols*cellSize,rows*cellSize);

    // subtle checker
    for(let x=0;x<cols;x++){
      for(let y=0;y<rows;y++){
        if ((x+y)%2===0){
          ctx.fillStyle = 'rgba(255,255,255,0.02)';
          ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
        }
      }
    }

    // draw food (larger circle)
    if (food){
      ctx.beginPath();
      ctx.fillStyle = food.type==='normal' ? '#ef4444' : '#f59e0b';
      const cx = food.x*cellSize + cellSize/2;
      const cy = food.y*cellSize + cellSize/2;
      const r = cellSize / 2.4;
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fill();
      // highlight
      if (food.type==='golden'){
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillRect(cx-2, cy-8, 4, 12);
      }
    }

    // draw snake (chunky)
    for(let i=0;i<snake.length;i++){
      const p = snake[i];
      if (i===snake.length-1){
        // head
        const grad = ctx.createLinearGradient(p.x*cellSize, p.y*cellSize, (p.x+1)*cellSize, (p.y+1)*cellSize);
        grad.addColorStop(0,'#34d399');
        grad.addColorStop(1,'#10b981');
        ctx.fillStyle = grad;
        roundRect(ctx, p.x*cellSize+1, p.y*cellSize+1, cellSize-2, cellSize-2, 6, true);
      } else {
        ctx.fillStyle = '#065f46';
        roundRect(ctx, p.x*cellSize+2, p.y*cellSize+2, cellSize-4, cellSize-4, 4, true);
      }
    }

    // HUD small
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(6,6,170,36);
    ctx.fillStyle = '#fff';
    ctx.font = '14px ui-sans-serif, system-ui';
    ctx.fillText(`Score: ${score}`, 12, 26);
    ctx.fillText(`High: ${highScore}`, 100, 26);
    if (!running && !gameOver){
      renderOverlay('Press SPACE or Tap to Start');
    }
    if (gameOver){
      renderOverlay('Game Over');
    }
  }

  function renderOverlay(text){
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    const w = 300, h=72;
    ctx.fillRect((cols*cellSize)/2 - w/2, (rows*cellSize)/2 - h/2, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = '18px ui-sans-serif';
    ctx.fillText(text, (cols*cellSize)/2 - (text.length*5), (rows*cellSize)/2 - 4);
    ctx.font = '13px ui-sans-serif';
    ctx.fillText('Space=Pause · R=Restart', (cols*cellSize)/2 - 78, (rows*cellSize)/2 + 18);
  }

  function roundRect(ctx,x,y,w,h,r,fill){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if (fill) ctx.fill();
  }

  // animation loop
  function frame(ts){
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;
    if (running && !gameOver){
      acc += dt;
      if (acc >= tickInterval){
        const loops = Math.max(1, Math.floor(acc / tickInterval));
        for(let i=0;i<Math.min(3,loops);i++) tick();
        acc = 0;
      }
    }
    render();
    requestAnimationFrame(frame);
  }

  // input
  window.addEventListener('keydown', (e)=>{
    if (e.key==='ArrowUp' || e.key==='w') setDir(0,-1);
    if (e.key==='ArrowDown' || e.key==='s') setDir(0,1);
    if (e.key==='ArrowLeft' || e.key==='a') setDir(-1,0);
    if (e.key==='ArrowRight' || e.key==='d') setDir(1,0);
    if (e.key===' ') { e.preventDefault(); toggleRunning(); }
    if (e.key==='r') { resetGame(); start(); }
  });

  // touch swipe
  let touchStart = null;
  canvas.addEventListener('touchstart', (e)=>{ touchStart = e.touches[0]; }, {passive:true});
  canvas.addEventListener('touchend', (e)=>{
    if (!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.clientX;
    const dy = t.clientY - touchStart.clientY;
    if (Math.abs(dx) > Math.abs(dy)){
      if (dx>20) setDir(1,0);
      else if (dx<-20) setDir(-1,0);
    } else {
      if (dy>20) setDir(0,1);
      else if (dy<-20) setDir(0,-1);
    }
    touchStart = null;
  }, {passive:true});

  canvas.addEventListener('pointerdown', ()=>{ if (!running) start(); });

  // UI wiring
  elStart.addEventListener('click', ()=>{ start(); });
  elReset.addEventListener('click', ()=>{ resetGame(); running=false; });
  elWrap.addEventListener('change', ()=>{ wrap = elWrap.checked; });
  elSpeed.addEventListener('input', ()=>{ speed = Number(elSpeed.value); });

  function start(){
    if (!snake.length) resetGame();
    running = true;
  }

  function toggleRunning(){
    if (gameOver){ resetGame(); start(); return; }
    running = !running;
  }

  // initialize
  resetGrid();
  resetGame();
  requestAnimationFrame(frame);

  // responsive
  window.addEventListener('resize', ()=>{
    resetGrid();
    render();
  });

})();
</script>
</body>
</html>
