import React, { useRef, useEffect, useState } from "react";

export default function SnakeGame() {
  const canvasRef = useRef(null);
  const animRef = useRef(null);
  const lastTickRef = useRef(0);

  const [cellSize] = useState(28); // Increased from 18 to make snake & apples bigger
  const [cols, setCols] = useState(32);
  const [rows, setRows] = useState(22);
  const [speed, setSpeed] = useState(8);
  const [wrap, setWrap] = useState(true);
  const [running, setRunning] = useState(false);
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(() => {
    const v = localStorage.getItem("snake_highscore_v2");
    return v ? Number(v) : 0;
  });

  const snakeRef = useRef([]);
  const dirRef = useRef({ x: 1, y: 0 });
  const nextDirRef = useRef(null);
  const foodRef = useRef({ x: 10, y: 10, type: "normal" });
  const tickIntervalRef = useRef(1000 / speed);
  const gameOverRef = useRef(false);
  const speedMultiplierRef = useRef(1);

  const touchStartRef = useRef(null);

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function placeFood(exclude = []) {
    let tries = 0;
    while (tries++ < 2000) {
      const x = randInt(0, cols - 1);
      const y = randInt(0, rows - 1);
      if (!exclude.some(p => p.x === x && p.y === y)) {
        const type = Math.random() < 0.08 ? "golden" : "normal";
        foodRef.current = { x, y, type };
        return;
      }
    }
  }

  function resetGame() {
    const startX = Math.floor(cols / 2);
    const startY = Math.floor(rows / 2);
    snakeRef.current = [
      { x: startX - 1, y: startY },
      { x: startX, y: startY },
    ];
    dirRef.current = { x: 1, y: 0 };
    nextDirRef.current = null;
    setScore(0);
    speedMultiplierRef.current = 1;
    gameOverRef.current = false;
    placeFood(snakeRef.current);
  }

  function setDirection(dx, dy) {
    const cur = dirRef.current;
    if (dx === -cur.x && dy === -cur.y) return;
    nextDirRef.current = { x: dx, y: dy };
  }

  useEffect(() => {
    function onKey(e) {
      if (e.key === "ArrowUp" || e.key === "w") setDirection(0, -1);
      if (e.key === "ArrowDown" || e.key === "s") setDirection(0, 1);
      if (e.key === "ArrowLeft" || e.key === "a") setDirection(-1, 0);
      if (e.key === "ArrowRight" || e.key === "d") setDirection(1, 0);
      if (e.key === " ") {
        e.preventDefault();
        toggleRunning();
      }
      if (e.key === "r") {
        startGame();
      }
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    function onTouchStart(e) {
      const t = e.touches[0];
      touchStartRef.current = { x: t.clientX, y: t.clientY };
    }
    function onTouchEnd(e) {
      const t0 = touchStartRef.current;
      if (!t0) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - t0.x;
      const dy = t.clientY - t0.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 20) setDirection(1, 0);
        else if (dx < -20) setDirection(-1, 0);
      } else {
        if (dy > 20) setDirection(0, 1);
        else if (dy < -20) setDirection(0, -1);
      }
      touchStartRef.current = null;
    }
    canvas.addEventListener("touchstart", onTouchStart, { passive: true });
    canvas.addEventListener("touchend", onTouchEnd, { passive: true });
    return () => {
      canvas.removeEventListener("touchstart", onTouchStart);
      canvas.removeEventListener("touchend", onTouchEnd);
    };
  }, [cols, rows]);

  useEffect(() => {
    function resizeCanvas() {
      const container = canvasRef.current?.parentElement;
      if (!container) return;
      const maxWidth = Math.floor(container.clientWidth - 40);
      const maxHeight = Math.floor(window.innerHeight * 0.6);
      const newCols = Math.max(10, Math.floor(maxWidth / cellSize));
      const newRows = Math.max(8, Math.floor(maxHeight / cellSize));
      setCols(newCols);
      setRows(newRows);

      const canvas = canvasRef.current;
      if (!canvas) return;
      canvas.width = newCols * cellSize;
      canvas.height = newRows * cellSize;
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = canvas.width + "px";
      canvas.style.height = canvas.height + "px";
      canvas.width = canvas.width * dpr;
      canvas.height = canvas.height * dpr;
      const ctx = canvas.getContext("2d");
      ctx.scale(dpr, dpr);
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    return () => window.removeEventListener("resize", resizeCanvas);
  }, [cellSize]);

  function tick() {
    if (gameOverRef.current) return;
    if (nextDirRef.current) {
      dirRef.current = nextDirRef.current;
      nextDirRef.current = null;
    }
    const dir = dirRef.current;
    const snake = snakeRef.current.slice();
    const head = snake[snake.length - 1];
    let newHead = { x: head.x + dir.x, y: head.y + dir.y };

    if (wrap) {
      if (newHead.x < 0) newHead.x = cols - 1;
      if (newHead.x >= cols) newHead.x = 0;
      if (newHead.y < 0) newHead.y = rows - 1;
      if (newHead.y >= rows) newHead.y = 0;
    } else {
      if (newHead.x < 0 || newHead.x >= cols || newHead.y < 0 || newHead.y >= rows) {
        return doGameOver();
      }
    }

    if (snake.some(p => p.x === newHead.x && p.y === newHead.y)) {
      return doGameOver();
    }

    snake.push(newHead);
    const food = foodRef.current;
    let ate = false;
    if (newHead.x === food.x && newHead.y === food.y) {
      ate = true;
      if (food.type === "normal") {
        setScore(s => s + 10);
      } else if (food.type === "golden") {
        setScore(s => s + 40);
        speedMultiplierRef.current = Math.min(2.2, speedMultiplierRef.current + 0.3);
      }
      placeFood(snake);
    }

    if (!ate) {
      snake.shift();
    }

    snakeRef.current = snake;
    speedMultiplierRef.current = Math.max(1, speedMultiplierRef.current - 0.02);
    const effectiveSpeed = speed * speedMultiplierRef.current + Math.floor(score / 80);
    tickIntervalRef.current = 1000 / effectiveSpeed;
  }

  function doGameOver() {
    gameOverRef.current = true;
    setRunning(false);
    setHighScore(prev => {
      const best = Math.max(prev, score);
      localStorage.setItem("snake_highscore_v2", String(best));
      return best;
    });
  }

  function render() {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, cols * cellSize, rows * cellSize);
    ctx.fillStyle = "#0f172a";
    ctx.fillRect(0, 0, cols * cellSize, rows * cellSize);

    for (let x = 0; x < cols; x++) {
      for (let y = 0; y < rows; y++) {
        if ((x + y) % 2 === 0) {
          ctx.fillStyle = "rgba(255,255,255,0.02)";
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
    }

    const f = foodRef.current;
    if (f) {
      ctx.fillStyle = f.type === "normal" ? "#ef4444" : "#f59e0b";
      ctx.beginPath();
      ctx.arc(f.x * cellSize + cellSize / 2, f.y * cellSize + cellSize / 2, cellSize / 2.5, 0, Math.PI * 2);
      ctx.fill();
    }

    const snake = snakeRef.current;
    for (let i = 0; i < snake.length; i++) {
      const p = snake[i];
      ctx.fillStyle = i === snake.length - 1 ? "#34d399" : "#065f46";
      ctx.fillRect(p.x * cellSize + 1, p.y * cellSize + 1, cellSize - 2, cellSize - 2);
    }

    ctx.fillStyle = "#fff";
    ctx.font = "14px ui-sans-serif";
    ctx.fillText(`Score: ${score}`, 12, 26);
    ctx.fillText(`High: ${highScore}`, 100, 26);
  }

  useEffect(() => {
    let acc = 0;
    function frame(ts) {
      if (!lastTickRef.current) lastTickRef.current = ts;
      const dt = ts - lastTickRef.current;
      lastTickRef.current = ts;
      if (running && !gameOverRef.current) {
        acc += dt;
        if (acc >= tickIntervalRef.current) {
          const loops = Math.max(1, Math.floor(acc / tickIntervalRef.current));
          for (let i = 0; i < Math.min(3, loops); i++) {
            tick();
          }
          acc = 0;
        }
      }
      render();
      animRef.current = requestAnimationFrame(frame);
    }
    animRef.current = requestAnimationFrame(frame);
    return () => {
      cancelAnimationFrame(animRef.current);
    };
  }, [running, cols, rows, score]);

  function startGame() {
    resetGame();
    setRunning(true);
  }

  function toggleRunning() {
    if (gameOverRef.current) return startGame();
    setRunning(r => !r);
  }

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    function onClick() {
      if (!running) startGame();
    }
    canvas.addEventListener("pointerdown", onClick);
    return () => canvas.removeEventListener("pointerdown", onClick);
  }, [running]);

  return (
    <div className="max-w-3xl mx-auto p-4">
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center gap-3">
          <h2 className="text-xl font-semibold">Upgraded Snake</h2>
          <div className="text-sm text-slate-500">Score: {score} Â· High: {highScore}</div>
        </div>
        <div className="flex gap-2 items-center">
          <label className="flex items-center gap-2 text-sm">
            <input type="checkbox" checked={wrap} onChange={() => setWrap(w => !w)} />
            Wrap
          </label>
          <label className="text-sm">Speed</label>
          <input type="range" min="4" max="18" value={speed} onChange={e => setSpeed(Number(e.target.value))} />
          <button className="px-3 py-1 rounded bg-sky-600 text-white text-sm" onClick={() => { startGame(); }}>Start</button>
          <button className="px-3 py-1 rounded border text-sm" onClick={() => { resetGame(); setRunning(false); }}>Reset</button>
        </div>
      </div>

      <div className="rounded-lg overflow-hidden shadow-lg bg-slate-800 p-4">
        <div style={{ touchAction: "none" }}>
          <canvas ref={canvasRef} style={{ width: "100%", display: "block", cursor: "pointer" }} />
        </div>
        <div className="mt-2 text-xs text-slate-300">
          Controls: Arrow keys / WASD. Tap or swipe to play on mobile. Space to pause, R to restart.
        </div>
      </div>
    </div>
  );
}

